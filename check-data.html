<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>データチェック</title>
  <style>
    body { margin: 20px; font-family: sans-serif; }
    table { border-collapse: collapse; margin-top: 20px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background: #f0f0f0; }
    .error { color: red; }
    .warning { color: orange; }
    .ok { color: green; }
  </style>
</head>
<body>
  <h1>都道府県データのチェック</h1>
  <div id="summary"></div>
  <table id="prefectureTable">
    <thead>
      <tr>
        <th>インデックス</th>
        <th>都道府県名</th>
        <th>コード</th>
        <th>ジオメトリタイプ</th>
        <th>ポリゴン数</th>
        <th>境界</th>
        <th>ステータス</th>
      </tr>
    </thead>
    <tbody id="tableBody"></tbody>
  </table>
  
  <script type="module">
    const summary = document.getElementById('summary');
    const tableBody = document.getElementById('tableBody');
    
    // データを読み込み
    const response = await fetch('./src/data/prefectures.geojson');
    const data = await response.json();
    
    // 都道府県名のリスト（正しい順序）
    const expectedPrefectures = [
      '北海道', '青森県', '岩手県', '宮城県', '秋田県', '山形県', '福島県',
      '茨城県', '栃木県', '群馬県', '埼玉県', '千葉県', '東京都', '神奈川県',
      '新潟県', '富山県', '石川県', '福井県', '山梨県', '長野県',
      '岐阜県', '静岡県', '愛知県', '三重県',
      '滋賀県', '京都府', '大阪府', '兵庫県', '奈良県', '和歌山県',
      '鳥取県', '島根県', '岡山県', '広島県', '山口県',
      '徳島県', '香川県', '愛媛県', '高知県',
      '福岡県', '佐賀県', '長崎県', '熊本県', '大分県', '宮崎県', '鹿児島県', '沖縄県'
    ];
    
    // 実際のデータをチェック
    const actualPrefectures = data.features.map(f => f.properties.N03_001);
    const missing = expectedPrefectures.filter(p => !actualPrefectures.includes(p));
    const extra = actualPrefectures.filter(p => !expectedPrefectures.includes(p));
    
    summary.innerHTML = `
      <p>データ内の都道府県数: ${data.features.length}</p>
      <p>期待される都道府県数: ${expectedPrefectures.length}</p>
      <p class="${missing.length > 0 ? 'error' : 'ok'}">
        不足している都道府県: ${missing.length > 0 ? missing.join(', ') : 'なし'}
      </p>
      <p class="${extra.length > 0 ? 'warning' : 'ok'}">
        予期しない都道府県: ${extra.length > 0 ? extra.join(', ') : 'なし'}
      </p>
    `;
    
    // 各都道府県の詳細をチェック
    data.features.forEach((feature, index) => {
      const row = tableBody.insertRow();
      
      // インデックス
      row.insertCell(0).textContent = index;
      
      // 都道府県名
      row.insertCell(1).textContent = feature.properties.N03_001 || 'N/A';
      
      // コード
      const code = feature.properties.N03_007 || 'なし';
      row.insertCell(2).textContent = code;
      
      // ジオメトリタイプ
      row.insertCell(3).textContent = feature.geometry.type;
      
      // ポリゴン数
      let polygonCount = 0;
      let totalPoints = 0;
      if (feature.geometry.type === 'MultiPolygon') {
        polygonCount = feature.geometry.coordinates.length;
        feature.geometry.coordinates.forEach(polygon => {
          polygon.forEach(ring => {
            totalPoints += ring.length;
          });
        });
      } else if (feature.geometry.type === 'Polygon') {
        polygonCount = 1;
        feature.geometry.coordinates.forEach(ring => {
          totalPoints += ring.length;
        });
      }
      row.insertCell(4).textContent = `${polygonCount} (${totalPoints}点)`;
      
      // 境界
      let bounds = '計算中...';
      try {
        let minLng = Infinity, maxLng = -Infinity;
        let minLat = Infinity, maxLat = -Infinity;
        
        const processCoord = (coord) => {
          if (Array.isArray(coord) && coord.length >= 2) {
            minLng = Math.min(minLng, coord[0]);
            maxLng = Math.max(maxLng, coord[0]);
            minLat = Math.min(minLat, coord[1]);
            maxLat = Math.max(maxLat, coord[1]);
          }
        };
        
        if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach(polygon => {
            polygon.forEach(ring => {
              ring.forEach(processCoord);
            });
          });
        } else if (feature.geometry.type === 'Polygon') {
          feature.geometry.coordinates.forEach(ring => {
            ring.forEach(processCoord);
          });
        }
        
        bounds = `西${minLng.toFixed(1)}, 東${maxLng.toFixed(1)}, 南${minLat.toFixed(1)}, 北${maxLat.toFixed(1)}`;
      } catch (e) {
        bounds = 'エラー: ' + e.message;
      }
      row.insertCell(5).textContent = bounds;
      
      // ステータス
      const statusCell = row.insertCell(6);
      if (totalPoints === 0) {
        statusCell.innerHTML = '<span class="error">座標なし</span>';
      } else if (totalPoints < 10) {
        statusCell.innerHTML = '<span class="warning">座標が少ない</span>';
      } else {
        statusCell.innerHTML = '<span class="ok">OK</span>';
      }
    });
  </script>
</body>
</html>